#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightLiftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftLiftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  ultrasonic,     sensorSONAR_inch)
#pragma config(Motor,  port1,           mobileGoalLift, tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           rightDriveBack, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftDriveBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           rightLift,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           leftLift,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           fourBar,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftDriveFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rightDriveFront, tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                         Driver Skills Template
//
// This is a template for the driver skills competition. It is identical in structure to
// the standard competition template except that the two "#pragma' statements above (and
// copied below) adjust the time limits for the competition.
//				#pragma autonomousDuration(0)
//				#pragma userControlDuration(60)
// The autonomous duration for "Driver Skills" is zero; i.e. there is no autonomous phase.
// The user control duration is 60 seconds
//
// NOTE: The above two pragmas only impact the Crystal implementation. For systems using
//       VEXNET, the VEXNET system ignores these statements as it has the durations
//       for the competition built-in.
//
// Whenever this user program is run, the duration is automatically sent to the VEX master
// processor. The master CPU will only accept these commands once per power=on cycle. So, it's
// best to power cycle your VEX to ensure that they get recognized in case you were
// previously running a standard competition program with different durations.
//
// Testing Via Crystals:
// ====================
//
// The procedure to test a Driver Skills program using the crystals is as follows:
//
// 1. Turn off power to the Crystal transmitter/joysticks.
//
// 2. Turn on your VEX so that the Driver Skills program is running.
//
// 3. Driver skills program segment of your program will start running. At the end of 60
//    seconds the VEX Master CPU will turn off the motors.
//
// 4. Repeat the above sequence
//
//
// Testing Via VEXNET Using VEXNET Competition Switch
// ==================================================
//
// The procedure to test a Driver Skills program using VEXNET Competition Switch is as follows:
//
// 1. Set the two switches on the Competition switch to "DISABLE" and "USER CONTROL"
//
// 2. Start the Driver skills program
//
// 3. Set Switch to ENABLE from DISABLE
//
// 4. You need to manually time the 60 second duration.
//
// 5. Set Switch to DISABLE
//
// 6. Repeat from step (3) to run subsequent test runs. There's no need to reset the VEX or
//    restart your user program.
//
//
// Testing Via VEXNET Using ROBOTC IDE
// ==================================================
//
// It is not necessary to own a VEXNET switch. ROBOTC has a test window that allows the same functionality.
// The test window has three buttons for "DISABLE", "AUTONOMOUS", "USER CONTROL".
//
// 1. Open the ROBOTC Debugger. Then open the "Competition Control" Debugger window.
//
// 2. Start your Driver Skills program running.
//
// 3. Click the "DISABLED" button on the "Competition Control" window.
//
// 4. Click the "USER CONTROL" button on the "Competition Control" window.
//
// 5. You need to manually time the 60 second duration.
//
// 6. Click the "DISABLED" button on the "Competition Control" window.
//
// 7. Repeat from step (4) to run subsequent test runs. There's no need to reset the VEX or
//    restart your user program.
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  SensorValue[gyro] = 0

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// The "Driver Skills" competition has no autonomous phase. Simply leave the following
// placeholder.
//
/////////////////////////////////////////////////////////////////////////////////////////

void chassisSet(int left, int right);
void liftSet(int left, int right);
void fourBarSet(int val);
void intakeSet(int val);
void mobileLiftSet(int val);

void encoderReset();

void autoStackLiftUp();
void autoStackLiftDown(int leftLiftInitialValue, int rightLiftInitialValue);
void encoderLiftMove(int objective);
void waitForEncoders(int objective, bool moveMG);
void initialConeStack();
void liftEncoderReset();
void dropMobileGoal(bool time);
void gyroCorrect();
void joshsAuton();
void gyroMove(int desiredGyro, int directionLeft,int directionRight);
void moveToMotorEncoderValue(int desiredValue, int direction);

task autonomous()
{

	const int imeValue = 1475;
	SensorValue[gyro] = 0;
	SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftDriveEncoder] = 0;
	SensorValue[rightLiftEncoder] = 0;
	SensorValue[leftLiftEncoder] = 0;

	chassisSet(0, 0);
	liftSet(0, 0);
	fourBarSet(0);
	intakeSet(0);

//UNCOMMENT UPTO HERE LATER!!!!
	//RUN JOSH's AUTON
	joshsAuton();
		chassisSet(1,1);
	//END OF JOSH's AUTON

//ROTATE SO YOU CAN BACK UP
	gyroMove(3000, -1, 1,);
	moveToMotorEncoderValue(665, -1);

	gyroMove(310, 1, -1 );
	//ROTATE TO PICK UP THE MG

	motor[mobileGoalLift] = 127;
	delay(1400);
	motor[mobileGoalLift] = 0;
	//MGL OUT
	SensorValue[rightDriveEncoder] = 0;
while(abs(SensorValue[rightDriveEncoder]) < 550){
	chassisSet(70,70);

}
chassisSet(0,0);


		//MOVE FORWARD TO PIC IT UP

	motor[mobileGoalLift] = -127;
	delay(1400);
	motor[mobileGoalLift] = 0;

	//ROTATE TO FACE SCORING ZONE

	gyroMove(2200, 1, -1 );


  //END OF FIRST MG

	SensorValue[rightDriveEncoder] = 0;
SensorValue[leftDriveEncoder] = 0;

delay(100)
//SCORE SCORE the Second Mobile Goal
	while(abs(SensorValue[rightDriveEncoder] ) < 960)
{

	chassisSet(90,90);
	if (abs(SensorValue[rightDriveEncoder] ) > 50){
		motor[mobileGoalLift] = 127;

	}
}
chassisSet(0,0);
delay(200);


  SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftDriveEncoder] = 0;

  //BackUp



	while(abs(SensorValue[rightDriveEncoder] ) < 300){
			motor[mobileGoalLift] = -127;
	 chassisSet(-90, -90);

	}

 mobileLiftSet(0);
  chassisSet(0, 0);
  delay(100)
///TURN FOR THE THIRD MG


	gyroMove(465, 1, -1 );

	//MOVE THE MG DOWN IN POSITION FOR THE THIRD MG


	motor[mobileGoalLift] = 127;
	delay(1400);
	motor[mobileGoalLift] = 0;
	//GO FORWARD

	 SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftDriveEncoder] = 0;

	while(abs(SensorValue[rightDriveEncoder] ) < 1050){

	 chassisSet(90, 90);

	}
	SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftDriveEncoder] = 0;

	while(abs(SensorValue[rightDriveEncoder] ) < 1200){
		motor[mobileGoalLift] = -127;
	 chassisSet(80, 80);

	}
	motor[mobileGoalLift] = 0;
	 chassisSet(0, 0);
	 delay(100);
	//TURN RIGHT


	 //GRYO RESTET
	 SensorValue[gyro] = 0;
	 while(abs(SensorValue[gyro] ) < 750){
	   chassisSet(70,-70);
	 }
	 chassisSet(0,0)


	//GO STRAIGHT PARALLEL TO POLE

	delay(100);
SensorValue[leftDriveEncoder] = 0;
SensorValue[rightDriveEncoder] = 0;

while(abs(SensorValue[rightDriveEncoder] ) < 280)
{
	chassisSet(90,90);

}
		chassisSet(-1,-1);
	//TURN LEFT
while(abs(SensorValue[gyro]) > 100){
		chassisSet(-60,60);

	}

	chassisSet(0,0);
	fourBarSet(100);

	 mobileLiftSet(0);
	  chassisSet(0, 0);
	 delay(300)
	//SCORE THIRD MB
	SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftDriveEncoder] = 0;
		while(abs(SensorValue[rightDriveEncoder] ) < 600){
		motor[mobileGoalLift] = 127;
	 chassisSet(127, 127);

	}
		fourBarSet(0);
	//BACKUP
	SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftDriveEncoder] = 0;
		while(abs(SensorValue[rightDriveEncoder] ) < 500){
		motor[mobileGoalLift] = -127;
	 chassisSet(-127, -127);

	}
	 mobileLiftSet(0);
	 chassisSet(0, 0);

//HI EVERYONE THIS IS PSEUDOCODE FOR THE NEXT 2 MOBILE GOALS











}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.

	  // .....................................................................................
	  // Insert user code here. This is where you use the joystick values to update your motors, etc.
	  // .....................................................................................

	  UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	  motor[port2] = vexRT[Ch1];							// Remove these as well and replace with your appropriate code
	  motor[port3] = vexRT[Ch4];							// Remove these as well and replace with your appropriate code
	}
}


void chassisSet(int left, int right) {
	motor[leftDriveBack] = left;
	motor[leftDriveFront] = left;
	motor[rightDriveBack] = right;
	motor[rightDriveFront] = right;
}
void liftSet(int left, int right) {
	motor[leftLift] = left;
	motor[rightLift] = right;
}
void fourBarSet(int val) {
	motor[fourBar] = val;
}
void intakeSet(int val) {
	motor[intake] = val;
}
void mobileLiftSet(int val) {
	motor[mobileGoalLift] = val;
}

void encoderReset() {
	SensorValue[leftDriveEncoder] = 0;
	SensorValue[rightDriveEncoder] = 0;
}
void liftEncoderReset(){
    SensorValue[rightLiftEncoder] = 0;
    SensorValue[leftLiftEncoder] = 0;

}
void autoStackLiftDown(int leftLiftInitialValue, int rightLiftInitialValue){
    while(SensorValue[leftLiftEncoder] > leftLiftInitialValue ){
        if(SensorValue[rightLiftEncoder] > rightLiftInitialValue){
        //the lift is higher than the initial value which it was triggered at
            liftSet(-60,-60);

        }
        liftSet(-60,-60);

    }

    liftSet(0,0);
//lol stop
    return;



}

void encoderLiftMove(int objective) {
	int startingEncoder = abs(SensorValue[leftLiftEncoder]);
  //may need to be switched depending on whether the encoder count up or down (negative)
  //using only the left encoder
  int speed = 0;

  //choose direction based off of
  if(startingEncoder < objective) {
    speed = 127;
  }
  else if(startingEncoder > objective) {
    speed = -127;
  }
  else {
    return;
  }

  liftSet(speed, speed);

  while(startingEncoder < objective ?
    SensorValue[leftLiftEncoder] <= objective :
    SensorValue[leftLiftEncoder] >= objective);

  liftSet(0, 0);
}

void waitForEncoders(int objective, bool moveMG) {
	while( abs(SensorValue[rightDriveEncoder]) <= objective) {

		if(moveMG && abs(SensorValue[rightDriveEncoder]) >= objective/1.90) mobileLiftSet(0);

		//because it's only necessary going forward for the first time
		if(moveMG) gyroCorrect();
	}
}

void initialConeStack() {

  intakeSet(-50);
  delay(300);
  intakeSet(0);
}

void dropMobileGoal(bool time) {
  //total time delayed should be 1475

  //move forward into 20 pt zone
  //and mobile goal down
  mobileLiftSet(127);
  delay(400);
  mobileLiftSet(0);

  chassisSet(127, 127);

  delay(500);
  mobileLiftSet(127);

  delay(800);
  mobileLiftSet(0);

  //back up a bit
  chassisSet(-127, -127);
  delay(300);
  chassisSet(0, 0);

  //mobile goal up
  mobileLiftSet(-127);
  delay(600);
  mobileLiftSet(0);
}

//might need to be changed if direcs are + vs. -
//dependent on the fact that left is +
void gyroCorrect() {
	if(SensorValue[gyro] > 10) chassisSet(127, 80);
	else if(SensorValue[gyro] < -10) chassisSet(80, 127);
	else chassisSet(127, 127);
}

void joshsAuton(){
	//start the thing

const int imeValue = 1405; //4704
  const bool blueTeam = true;

  intakeSet(40);

  chassisSet(0, 0);
  liftSet(100, 100);
  fourBarSet(100);
  mobileLiftSet(127);
  delay(100);
  fourBarSet(0);
  delay(200); //give time for lift to go up
  liftSet(0, 0);

  delay(300);

  //start moving forward
  chassisSet(90, 90);
	waitForEncoders(imeValue, true);
  chassisSet(0, 0);

  //pick up mobile goal
  mobileLiftSet(-127);
  delay(1400);
  mobileLiftSet(0);

  initialConeStack();

  //move backwards
  encoderReset();
  chassisSet(-90, -90);
  waitForEncoders(imeValue, false);
  chassisSet(0, 0);

  delay(200);


  int rotationSpeed = 85;



/*
//BEGIN TEMP ADDITION
  //turn
  gyroReset(gyro);
  blueTeam ? chassisSet(rotationSpeed, -rotationSpeed) : chassisSet(-rotationSpeed, rotationSpeed);
  while(abs(gyroGet(gyro)) < 180);
  blueTeam ? chassisSet(-rotationSpeed, rotationSpeed) : chassisSet(rotationSpeed, -rotationSpeed);
  chassisSet(0, 0);

  chassisSet(127, 127);
  delay(300);
  chassisSet(0, 0);

  mobileLiftSet(127);
  delay(1400);
  mobileLiftSet(0);

  chassisSet(-127, -127);
  delay(500);
  chassisSet(0, 0);
//END TEMP ADDITION
*/




  //turn
  //blueTeam ? chassisSet(rotationSpeed, -rotationSpeed) : chassisSet(-rotationSpeed, rotationSpeed);
  //while(abs(SensorValue[gyro]) < 1200);
  //blueTeam ? chassisSet(-rotationSpeed, rotationSpeed) : chassisSet(rotationSpeed, -rotationSpeed);
  //chassisSet(0, 0);

  //encoderReset();
  ////move forward
  //chassisSet(127, 127);
  //waitForEncoders(275, false);
  //chassisSet(0, 0);

  ////turn to face goal
  //SensorValue[gyro] = 0;
  //blueTeam ? chassisSet(rotationSpeed, -rotationSpeed) : chassisSet(-rotationSpeed, rotationSpeed);
  //while(abs(SensorValue[gyro]) < 700);
  //blueTeam ? chassisSet(-rotationSpeed, rotationSpeed) : chassisSet(rotationSpeed, -rotationSpeed);
  //chassisSet(0, 0);
//FIRST ROTATION
while(abs(SensorValue[gyro]) < 1150 ){
	chassisSet(-70,70);
}
chassisSet(0,0);

delay(1000);
SensorValue[leftDriveEncoder] = 0;
SensorValue[rightDriveEncoder] = 0;

while(abs(SensorValue[rightDriveEncoder] ) < 250)
{
	chassisSet(80,80);

}
while(abs(SensorValue[gyro]) < 2129 ){
	chassisSet(-80,80);
}
chassisSet(0,0);

  liftSet(100, 100);
  delay(150);
  liftSet(0, 0);

  //drop off mobile goal
  dropMobileGoal(false);

  //if lift gets stuck
  mobileLiftSet(-127);
  delay(600);
  mobileLiftSet(0);

  chassisSet(-90, -90);
  delay(500);
  chassisSet(0, 0);
  //ROTATE SO YOU CAN BACK UP TO THE WALL


chassisSet(0,0);
//BACK UP TO THE WALL

}
//-1 as direction makes it move backwards

void moveToMotorEncoderValue(int desiredValue, int direction){
	SensorValue[rightDriveEncoder] = 0;

		int currentValue = SensorValue[rightDriveEncoder];
	while(currentValue  < desiredValue - 40 || currentValue  > desiredValue + 40  ){
		currentValue = SensorValue[rightDriveEncoder];
		int h = (desiredValue - currentValue) * 0.25;
		chassisSet(direction * h,direction * h);
		delay(50);
	}
	chassisSet(0,0);

}

void gyroMove(int desiredGyro, int directionLeft,int directionRight){
	int currentGyro = SensorValue[gyro];
	while(currentGyro  < desiredGyro - 30 || currentGyro  > desiredGyro + 30 ){
		currentGyro = SensorValue[gyro];
		int h = (desiredGyro - currentGyro) * 0.15;
		chassisSet( -h, h);
		delay(50);

	}
		chassisSet(0,0);


	}
